{
  "hash": "0f8d1e5fcaa20f39a1ed76ecd97e62ee",
  "result": {
    "engine": "knitr",
    "markdown": "# Running a R script on the command line\n\n## The Basic Process\n\n1. Specify named arguments for your R script.\n1. Wrap running `Rscript` in a bash file, passing on arguments to the R Script\n1. Use `bash` to execute your bash script, with appropriate arguments.\n\n:::{.callout}\n## For FH Users\n\nIn your bash script you'll need to load the appropriate environment module (usually at least `fhR`):\n\n```\nmodule load fhR/4.3.3-foss-2023b\n```\n\nYou can also run things from the Bioconductor / Rocker containers using Apptainer (@sec-fh-apptainer).\n:::\n\n## Using `Rscript` on the command-line\n\nLet's talk about wrapping R scripts in a Bash script. This might seem like an extra layer of redundancy, but remember that we need to specify our software environment before we run something, so our bash script lets us do that.\n\nOur main executable for running R on the command-line is `Rscript`. \n\nWhen we run R on the command line, it will look something like this:\n\n```bash\nRscript process_data.R --input_file=my_genome_file.vcf\n```\nNote that you can have named inputs when you run on the command line, \n\n## Wrapping it up in a bash script\n\nSay you have an R Script you need to run on the command line. In our bash script, we can do the following:\n\n\n::: {.cell filename='scripting-basics/wrap_r_script.sh'}\n\n```{.bash .cell-code}\n#!/bin/bash\nRscript process_data.R input_file=\"${1}\"\n```\n:::\n\n\nThis calls `Rscript`, which is the command line executable, to run our R script. Note that we have a named argument called `input_file` and it is done differently than in Bash - how do we use this in our R Script?\n\n### Using Named Arguments in an R script\n\nWe can pass arguments from our bash script to our R script by using `commandArgs()` - this will populate a list of named arguments (such as `CSVFILE`) that are passed into the R Script. We assign the output of `commandArgs()` into the `args` object.\n\nWe refer to our `CSVFILE` argument as `args$CSVFILE` in our script.\n\n\n::: {.cell filename='scripting-basics/r_script.R'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nargs <- commandArgs()\n# Use arg$CSVFILE in read.csv\ncsv_file <- read.csv(file=args$input_file)\n\n# Do some work with csv_file\ncsv_filtered <- csv_file |> dplyr::filter()\n\n# Write output\nwrite.csv(csv_filtered, file = paste0(args$CSVFILE, \"_filtered.csv\"))\n```\n:::\n\n\n### Running our R Script\n\nNow that we've set it up, we can run the R script from the command line as follows:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nbash my_bash_script.sh my_csvfile.csv \n```\n:::\n\n\nIn our bash script, `my_bash_script.sh`, we're using positional argument (for simplicity) to specify our csvfile, and then passing the positional argument to named ones (`CSVFILE`) for `my_r_script.R`.\n\n## Quarto Documents\n\nQuarto is the next generation of RMarkdown and supports a number of output formats.\n\nYou might want to apply a workflow that you've built in a quarto document. \n\nThe main difference is that you'd use `quarto run` rather than `Rscript run`. \n\n\n::: {.cell}\n\n```{.bash .cell-code}\n#!/bin/bash\nquarto run my_quarto_doc.qmd \n```\n:::\n\n\n## Apptainer {#sec-apptainer}\n\nApptainer (previous Singularity) is a secure way to run Docker containers on a HPC system. The commands are very similar to Docker, but aren't.",
    "supporting": [
      "r-commandline_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}